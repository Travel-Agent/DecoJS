{
  "version": 3,
  "file": "Dist/ordnung.js",
  "sources": [
    "../Source/utils.js",
    "../Source/qvc/ExecutableResult.js",
    "../Source/qvc/Constraint.js",
    "../Source/qvc/Validator.js",
    "../Source/qvc/koExtensions.js",
    "../Source/qvc/Validatable.js",
    "../Source/qvc/Executable.js",
    "../Source/ajax.js",
    "../Source/qvc/ConstraintResolver.js",
    "../Source/qvc.js",
    "../Source/spa/Outlet.js",
    "../Source/spa/EventSubscriber.js",
    "../node_modules/when/when.js",
    "../node_modules/when/callbacks.js",
    "../Source/spa/applyViewModels.js",
    "../Source/spa/hashNavigation.js",
    "../Source/spa/PageLoader.js",
    "../Source/spa/Templates.js",
    "../Source/spa.js",
    "../Source/proclaimWhen.js",
    "../Source/qvc/constraints/NotEmpty.js",
    "../Source/qvc/constraints/Pattern.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA,ADgDA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA,ADeA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA,ADyBA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA,ADwCA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA,AD8BA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3IA,AD4IA;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzFA,AD0FA;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA,ADgEA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA,ADiDA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5HA,AD6HA;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA,ADsDA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA,AD+BA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACt4BA,ADu4BA;ACt4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9PA,AD+PA;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA,AD8CA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA,ADqFA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA,AD+BA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA,ADqDA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA,AD4DA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA,ADuDA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA,ADaA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\ndefine('ordnung/utils',[], function(){\r\n\treturn {\r\n\t\ttoArray: function(obj){\r\n\t\t\tvar array = [];\r\n\t\t\t// iterate backwards ensuring that length is an UInt32\r\n\t\t\tfor (var i = obj.length >>> 0; i--;) { \r\n\t\t\t\tarray[i] = obj[i];\r\n\t\t\t}\r\n\t\t\treturn array;\r\n\t\t},\r\n\t\textend: function(dst, src){\r\n\t\t\tsrc = src || {};\r\n\t\t\tdst = dst || {};\r\n\t\t\tfor(var i in src){\r\n\t\t\t\tdst[i] = src[i];\r\n\t\t\t}\r\n\t\t\treturn dst;\r\n\t\t},\r\n\t\tarrayToObject: function(array, func){\r\n\t\t\treturn array.reduce(function(collection, item){\r\n\t\t\t\tfunc(item, collection);\r\n\t\t\t\treturn collection;\r\n\t\t\t}, {});\r\n\t\t},\r\n\t\ttrim: function(word, character){\r\n\t\t\twhile(word.charAt(0) == character) word = word.substr(1);\r\n\t\t\twhile(word.charAt(word.length - 1) == character) word = word.substr(0, word.length - 1);\r\n\t\t\treturn word;\r\n\t\t},\r\n\t\tpopTail: function(array){\r\n\t\t\treturn array.slice(0, -1);\r\n\t\t},\r\n\t\tstartsWith: function(word, character){\r\n\t\t\treturn word.charAt(0) === character;\r\n\t\t},\r\n\t\tendsWith: function(word, character){\r\n\t\t\treturn word.charAt(word.length - 1) === character;\r\n\t\t},\r\n\t\taddEventListener: function(element, event, listener, bubble){\r\n\t\t\tif('addEventListener' in element){\r\n\t\t\t\telement.addEventListener(event, listener, bubble);\r\n\t\t\t}else{\r\n\t\t\t\telement.attachEvent(\"on\"+event, listener);\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n",
    "\ndefine('ordnung/qvc/ExecutableResult',[\"ordnung/utils\"], function(utils){\r\n\tfunction ExecutableResult(result){\r\n\t\t\r\n\t\tthis.success = false;\r\n\t\tthis.valid = false;\r\n\t\tthis.result = null;\r\n\t\tthis.exception = null;\r\n\t\tthis.violations = [];\r\n\t\r\n\t\tutils.extend(this, result);\r\n\t\r\n\t};\r\n\t\r\n\treturn ExecutableResult;\r\n});",
    "\ndefine('ordnung/qvc/Constraint',[], function(){\r\n\t\r\n\tfunction Constraint(name, attributes){\t\t\r\n\t\tthis.name = name;\r\n\t\tthis.attributes = attributes;\r\n\t\tthis.message = attributes.message;\r\n\t\t\r\n\t\t\r\n\t\tthis.init(name);\r\n\t}\r\n\t\t\r\n\tConstraint.prototype.init = function(name){\r\n\t\trequire([\"ordnung/qvc/constraints/\" + name], function(Tester){\r\n\t\t\tvar tester = new Tester(this.attributes);\r\n\t\t\tthis.validate = tester.isValid.bind(tester);\r\n\t\t}.bind(this));\r\n\t};\r\n\t\r\n\tConstraint.prototype.validate = function(value){\r\n\t\treturn true;//real test not loaded yet\r\n\t};\r\n\t\r\n\t\r\n\treturn Constraint;\r\n});",
    "\ndefine('ordnung/qvc/Validator',[\"ordnung/qvc/Constraint\", \"knockout\"], function(Constraint, ko){\r\n\tfunction Validator(){\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tthis.constraints = [];\r\n\t\t\r\n\t\tthis.isValid = ko.observable(true);\r\n\t\tthis.message = ko.observable(\"\");\r\n\t}\r\n\t\r\n\tValidator.prototype.setConstraints = function(constraints){\r\n\t\tthis.constraints = constraints.map(function(constraint){\r\n\t\t\treturn new Constraint(constraint.name, constraint.attributes);\r\n\t\t});\r\n\t};\r\n\t\r\n\tValidator.prototype.reset = function(){\r\n\t\tthis.isValid(true);\r\n\t\tthis.message(\"\");\r\n\t};\r\n\t\r\n\tValidator.prototype.validate = function(value){\r\n\t\tif(this.constraints.length == 0){\r\n\t\t\tthis.reset();\r\n\t\t}else if(this.constraints.every(function (constraint) {\r\n\t\t\tif(constraint.validate(value)){\r\n\t\t\t\treturn true;\r\n\t\t\t}else{\r\n\t\t\t\tthis.isValid(false);\r\n\t\t\t\tthis.message(constraint.message);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}.bind(this))){\r\n\t\t\tthis.isValid(true);\r\n\t\t\tthis.message(\"\");\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn Validator;\r\n});",
    "\ndefine('ordnung/qvc/koExtensions',[\"ordnung/qvc/Validator\", \"knockout\"], function(Validator, ko){\r\n\r\n\tif (ko != null) {\r\n\t\tko.bindingHandlers.validationMessageFor = {\r\n\t\t\tinit: function (element, valueAccessor, allBindingsAccessor, viewModel) {\r\n\t\t\t\tvar value = valueAccessor();\r\n\t\t\t\tvar validator = value.validator;\r\n\t\t\t\tif (validator) {\r\n\t\t\t\t\tko.applyBindingsToNode(element, { hidden: validator.isValid, text: validator.message }, validator);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tko.extenders.validation = function (target, options) {\r\n\t\t\ttarget.validator = new Validator(target, options);\r\n\t\t\ttarget.subscribe(function (newValue) {\r\n\t\t\t\ttarget.validator.validate(newValue);\r\n\t\t\t});\r\n\t\t\treturn target;\r\n\t\t};\r\n\t\t\r\n\t\tko.bindingHandlers.command = ko.bindingHandlers.query = {\r\n\t\t\tinit: function (element, valueAccessor, allBindingAccessor, viewModel) {\r\n\t\t\t\tko.applyBindingsToNode(element, { click: valueAccessor() }, viewModel);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\r\n});",
    "\ndefine('ordnung/qvc/Validatable',[\"ordnung/utils\", \"ordnung/qvc/Validator\", \"knockout\", \"ordnung/qvc/koExtensions\"],function(utils, Validator, ko){\r\n\t\r\n\tfunction recursivlyExtendParameters(parameters, validatableFields) {\r\n\t\tfor (var key in parameters) {\r\n\t\t\tvar property = parameters[key];\r\n\t\t\tif (ko.isObservable(property)) {\r\n\t\t\t\tproperty.extend({ validation: {} });\r\n\t\t\t\tvalidatableFields.push(property);\r\n\t\t\t}\r\n\t\t\tproperty = ko.utils.unwrapObservable(property);\r\n\t\t\tif (typeof property === \"object\") {\r\n\t\t\t\trecursivlyExtendParameters(property, validatableFields);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction findField(fieldPath, parameters, errorMessage){\r\n\t\treturn fieldPath.split(\".\").reduce(function(object, name){\r\n\t\t\tvar path = object.path;\r\n\t\t\tvar field = ko.utils.unwrapObservable(object.field);\r\n\t\t\tif (name in field) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tfield: field[name],\r\n\t\t\t\t\tpath: path + \".\" + name\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(errorMessage + \": \" + fieldPath + \"\\n\" +\r\n\t\t\t\t\tname + \" is not a member of \" + path + \"\\n\" +\r\n\t\t\t\t\tpath + \" = `\" + ko.toJSON(field) + \"`\");\r\n\t\t\t}\r\n\t\t}, {\r\n\t\t\tfield: parameters,\r\n\t\t\tpath: \"parameters\"\r\n\t\t}).field;\r\n\t}\r\n\r\n\r\n\r\n\t\r\n\tfunction applyViolationMessageToField(parameters, fieldPath, message) {\r\n\t\tvar object = findField(fieldPath, parameters, \"Error applying violation\");\r\n\t\t\r\n\t\tif (typeof message === \"string\" && \"validator\" in object) {\r\n\t\t\tobject.validator.isValid(false);\r\n\t\t\tobject.validator.message(message);\r\n\t\t}else{\r\n\t\t\tthrow new Error(\"Error applying violation\\n\"+fieldPath+\" is not validatable\\nit should be an observable\");\r\n\t\t}\r\n\t};\r\n\r\n\tfunction applyViolationMessageToValidatable(validatable, message) {\r\n\t\tvalidatable.validator.isValid(false);\r\n\t\tvar oldMessage = validatable.validator.message();\r\n\t\tvar newMessage = oldMessage.length == 0 ? message : oldMessage + \", \" + message;\r\n\t\tvalidatable.validator.message(newMessage);\r\n\t};\r\n\r\n\r\n\r\n\tfunction Validatable(name, parameters, constraintResolver){\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tthis.validator = new Validator();\r\n\t\tthis.validatableFields = [];\r\n\t\tthis.validatableParameters = parameters;\r\n\t\t\r\n\t\t\r\n\t\tinit: {\r\n\t\t\trecursivlyExtendParameters(self.validatableParameters, self.validatableFields);\r\n\t\t\tif(constraintResolver)\r\n\t\t\t\tconstraintResolver.applyValidationConstraints(name, self);\r\n\t\t}\r\n\t}\r\n\t\r\n\tValidatable.prototype.isValid = function () {\r\n\t\treturn this.validatableFields.every(function(constraint){\r\n\t\t\treturn constraint.validator && constraint.validator.isValid();\r\n\t\t}) && this.validator.isValid();\r\n\t};\r\n\t\t\r\n\tValidatable.prototype.applyViolations = function(violations){\r\n\t\tviolations.forEach(function(violation){\r\n\t\t\tvar message = violation.message;\r\n\t\t\tvar fieldName = violation.fieldName;\r\n\t\t\tif (fieldName.length > 0) {\r\n\t\t\t\t//one of the fields violates a constraint\r\n\t\t\t\tapplyViolationMessageToField(this.validatableParameters, fieldName, message);\r\n\t\t\t} else {\r\n\t\t\t\t//the validatable violates a constraint\r\n\t\t\t\tapplyViolationMessageToValidatable(this, message);\r\n\t\t\t}\r\n\t\t}.bind(this));\r\n\t};\r\n\t\r\n\tValidatable.prototype.applyConstraints = function(fields){\r\n\t\tvar parameters = this.validatableParameters;\r\n\t\t\r\n\t\tfields.forEach(function(field){\r\n\t\t\tvar fieldName = field.name;\r\n\t\t\tvar constraints = field.constraints;\r\n\t\t\t\r\n\t\t\tvar object = findField(fieldName, parameters, \"Error applying constraints to field\");\r\n\t\t\t\r\n\t\t\tif (ko.isObservable(object) && \"validator\" in object) {\r\n\t\t\t\tobject.validator.setConstraints(constraints);\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(\"Error applying constraints to field: \" + fieldName + \"\\n\" +\r\n\t\t\t\t\t\"It is not an observable or is not extended with a validator. \\n\" +\r\n\t\t\t\t\tfieldName + \"=`\" + ko.toJSON(object) + \"`\");\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t\r\n\tValidatable.prototype.validate = function(){\r\n\t\tthis.validator.validate(true);\r\n\t\tif (this.validator.isValid()) {\r\n\t\t\tthis.validatableFields.forEach(function(constraint){\r\n\t\t\t\tvar validator = constraint.validator;\r\n\t\t\t\tif (validator) {\r\n\t\t\t\t\tvalidator.validate(constraint());\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\t\r\n\tValidatable.prototype.clearValidationMessages = function () {\r\n\t\tthis.validator.reset();\r\n\t\tthis.validatableFields.forEach(function(constraint){\r\n\t\t\tvar validator = constraint.validator;\r\n\t\t\tif (validator) {\r\n\t\t\t\tvalidator.reset();\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\treturn Validatable;\r\n});",
    "\ndefine('ordnung/qvc/Executable',[\"ordnung/qvc/ExecutableResult\", \"ordnung/qvc/Validatable\", \"ordnung/utils\", \"knockout\"], function(ExecutableResult, Validatable, utils, ko){\r\n\r\n\tfunction Executable(name, type, parameters, callbacks, qvc){\r\n\t\tvar self = this;\r\n\t\t\r\n\t\tthis.name;\r\n\t\tthis.type;\r\n\t\tthis.isBusy = ko.observable(false);\r\n\t\tthis.hasError = ko.observable(false);\r\n\t\tthis.result = new ExecutableResult();\r\n\t\t\r\n\t\tthis.parameters = {};\r\n\t\tthis.callbacks = {\r\n\t\t\tbeforeExecute: function () {},\r\n\t\t\tcanExecute: function(){return true;},\r\n\t\t\terror: function () {},\r\n\t\t\tsuccess: function () {},\r\n\t\t\tresult: function(){},\r\n\t\t\tcomplete: function () {}\r\n\t\t};\r\n\t\t\r\n\t\t\r\n\t\tthis.execute = function () {\r\n\t\t\tif (self.onBeforeExecute() === false) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tqvc.execute(self);\r\n\t\t};\r\n\r\n\t\tthis.onBeforeExecute = function () {\r\n\t\t\t\r\n\t\t\tif (self.isBusy()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tself.hasError(false);\r\n\t\t\t\r\n\t\t\tself.callbacks.beforeExecute();\r\n\t\t\t\r\n\t\t\tself.validate();\r\n\t\t\tif (!self.isValid()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (self.callbacks.canExecute() === false) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tself.isBusy(true);\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t};\r\n\t\t\r\n\t\t\r\n\t\tthis.onError = function () {\r\n\t\t\tself.hasError(true);\r\n\t\t\tif(\"violations\" in self.result)\r\n\t\t\t\tself.applyViolations(self.result.violations);\r\n\t\t\tself.callbacks.error(self.result);\r\n\t\t};\r\n\r\n\t\tthis.onSuccess = function () {\r\n\t\t\tself.hasError(false);\r\n\t\t\tself.clearValidationMessages();\r\n\t\t\tself.callbacks.success(self.result);\r\n\t\t\tself.callbacks.result(self.result.result);\r\n\t\t};\r\n\r\n\t\tthis.onComplete = function () {\r\n\t\t\tif (!self.hasError()) {\r\n\t\t\t\tself.callbacks.complete(self.result);\r\n\t\t\t\tself.clearValidationMessages();\r\n\t\t\t}\r\n\t\t\tself.isBusy(false);\r\n\t\t};\r\n\t\t\r\n\t\t\r\n\t\tinit: {\r\n\t\t\tself.name = name;\r\n\t\t\tself.type = type;\r\n\t\t\tutils.extend(self.parameters, parameters);\r\n\t\t\tutils.extend(self.callbacks, callbacks);\r\n\t\t\tutils.extend(self, new Validatable(self.name, self.parameters, qvc.constraintResolver));\r\n\t\t}\r\n\t}\r\n\t\r\n\tExecutable.Command = \"command\";\r\n\tExecutable.Query = \"query\";\r\n\t\r\n\treturn Executable;\r\n});",
    "\ndefine('ordnung/ajax',[], function(){\r\n\tfunction dataToParams(data){\r\n\t\tvar params = []\r\n\t\tfor(var key in data){\r\n\t\t\tvar value = data[key];\r\n\t\t\tparams.push(key + \"=\" + encodeURIComponent(value));\r\n\t\t}\r\n\t\treturn params.join(\"&\");\r\n\t}\r\n\r\n\tfunction addParamToUrl(url, name, value){\r\n\t\treturn url + (url.match(/\\?/) ? (url.match(/&$/) ? \"\" : \"&\") : \"?\") + encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\r\n\t}\r\n\r\n\tfunction addToPath(url, segment){\r\n\t\treturn url + (url.match(/\\/$/) ? \"\" : \"/\") + segment;\r\n\t}\r\n\r\n\r\n\tfunction ajax(url, object, method, callback){\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\t\r\n\t\tvar isPost = (method === \"POST\");\r\n\t\tvar data = null;\r\n\t\t\r\n\t\tif(object){\r\n\r\n\t\t\tif(isPost){\r\n\t\t\t\tdata = dataToParams(object);\r\n\t\t\t} else {\r\n\t\t\t\turl += \"?\" + dataToParams(object);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(isPost){\r\n\t\t\turl = addParamToUrl(url, \"cacheKey\", Math.floor(Math.random()*10000));\r\n\t\t}\r\n\r\n\t\txhr.open(isPost ? \"POST\" : \"GET\", url, true);\r\n\t\t\r\n\t\tif(isPost && data){\r\n\t\t\txhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\r\n\t\t\txhr.setRequestHeader(\"Content-length\", data.length);\r\n\t\t\txhr.setRequestHeader(\"Connection\", \"close\");\r\n\t\t}\r\n\t\t\r\n\t\txhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\r\n\t\t\r\n\t\txhr.onreadystatechange = function(){\r\n\t\t\tif(xhr.readyState == 4){\r\n\t\t\t\tcallback(xhr);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\txhr.send(data);\r\n\t\treturn xhr;\r\n\t}\r\n\r\n\tajax.addParamToUrl = addParamToUrl;\r\n\tajax.addToPath = addToPath;\r\n\r\n\r\n\treturn ajax;\r\n});",
    "\ndefine('ordnung/qvc/ConstraintResolver',[], function(){\r\n\r\n\r\n\tfunction findConstraint(name, constraints) {\r\n\t\tfor (var i = 0; i < constraints.length; i++) {\r\n\t\t\tif (constraints[i].name == name) {\r\n\t\t\t\treturn constraints[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction constraintsLoaded(name, fields){\r\n\t\tvar constraint = findConstraint(name, this.constraints);\r\n\t\tif(constraint){\r\n\t\t\tconstraint.validatables.forEach(function(validatable){\r\n\t\t\t\tvalidatable.applyConstraints(fields);\r\n\t\t\t});\r\n\t\t\tconstraint.fields = fields;\r\n\t\t\tconstraint.state = \"loaded\";\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction ConstraintResolver(qvc){\r\n\t\tthis.qvc = qvc;\r\n\t\tthis.constraints = [];\r\n\t}\r\n\t\r\n\tConstraintResolver.prototype.applyValidationConstraints = function(name, validatable){\r\n\t\tvar constraint = findConstraint(name, this.constraints);\r\n\t\tif(constraint == false){\r\n\t\t\tthis.constraints.push({\r\n\t\t\t\tname: name,\r\n\t\t\t\tstate: \"loading\",\r\n\t\t\t\tvalidatables: [validatable]\r\n\t\t\t});\r\n\t\t\tthis.qvc.loadConstraints(name, constraintsLoaded.bind(this));\r\n\t\t}else{\r\n\t\t\tif(constraint.state === \"loading\"){\r\n\t\t\t\tconstraint.validatables.push(validatable);\r\n\t\t\t}else{\r\n\t\t\t\tvalidatable.applyConstraints(constraint.fields);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn ConstraintResolver;\r\n});",
    "\ndefine('ordnung/qvc',[\r\n\t\"ordnung/qvc/Executable\", \r\n\t\"ordnung/qvc/ExecutableResult\", \r\n\t\"ordnung/utils\", \r\n\t\"ordnung/ajax\",\r\n\t\"ordnung/qvc/ConstraintResolver\",\r\n\t\"knockout\", \r\n\t\"ordnung/qvc/koExtensions\"], \r\n\tfunction(\r\n\t\tExecutable,\r\n\t\tExecutableResult,\r\n\t\tutils,\r\n\t\tajax,\r\n\t\tConstraintResolver,\r\n\t\tko){\r\n\t\r\n\tfunction QVC(){\r\n\r\n\t\tvar qvc = this;\r\n\r\n\t\tthis.constraintResolver = new ConstraintResolver(qvc);\r\n\r\n\t\tthis.execute = function(executable){\r\n\t\t\tvar parameters = ko.toJS(executable.parameters);\r\n\t\t\tvar data = {\r\n\t\t\t\tparameters: JSON.stringify(parameters),\r\n\t\t\t\tcsrfToken: qvc.config.csrf\r\n\t\t\t};\r\n\t\t\tvar url = ajax.addToPath(qvc.config.baseUrl, executable.type + \"/\" + executable.name);\r\n\t\t\tajax(url, data, \"POST\", function (xhr) {\r\n\t\t\t\tif (xhr.status === 200) {\r\n\t\t\t\t\texecutable.result = new ExecutableResult(JSON.parse(xhr.responseText || \"{}\"));\r\n\t\t\t\t\tif (executable.result.success === true) {\r\n\t\t\t\t\t\texecutable.onSuccess();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\texecutable.onError();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\texecutable.result = new ExecutableResult({exception: {message: xhr.responseText, cause: xhr}});\r\n\t\t\t\t\texecutable.onError();\r\n\t\t\t\t}\r\n\t\t\t\texecutable.onComplete();\r\n\t\t\t});\r\n\t\t\r\n\t\t};\r\n\t\t\r\n\t\tthis.loadConstraints = function(name, callback){\r\n\t\t\tvar url = ajax.addToPath(qvc.config.baseUrl, \"constraints/\" + name);\r\n\t\t\tajax(url, null, \"GET\", function(xhr){\r\n\t\t\t\tif (xhr.status === 200) {\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvar response = JSON.parse(xhr.responseText || \"{\\\"parameters\\\":[]}\");\r\n\t\t\t\t\t\tif(\"parameters\" in response == false){\r\n\t\t\t\t\t\t\tresponse.parameters = [];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\tvar response = {parameters: []};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcallback(name, response.parameters);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t\r\n\t\tthis.config = {\r\n\t\t\tbaseUrl: \"/\",\r\n\t\t\tcsrf: \"\"\r\n\t\t}\r\n\t};\r\n\r\n\tvar qvc = new QVC();\r\n\t\r\n\tfunction createExecutable(name, type, parameters, callbacks){\r\n\t\tif(name == null || name.length == 0)\r\n\t\t\tthrow new Error(type + \" is missing name\\nA \" + type + \" must have a name!\\nusage: createCommand('name', [parameters, callbacks])\");\r\n\t\r\n\t\tvar executable = new Executable(name, type, parameters || {}, callbacks || {}, qvc);\r\n\t\tvar execute = executable.execute.bind(executable);\r\n\t\texecute.isValid = ko.computed(function(){return executable.isValid(); });\r\n\t\texecute.isBusy = ko.computed(function(){return executable.isBusy();});\r\n\t\texecute.hasError = ko.computed(function(){return executable.hasError();});\r\n\t\texecute.success = function(callback){\r\n\t\t\texecutable.callbacks.success = callback;\r\n\t\t\treturn execute;\r\n\t\t};\r\n\t\texecute.error = function(callback){\r\n\t\t\texecutable.callbacks.error = callback;\r\n\t\t\treturn execute;\r\n\t\t};\r\n\t\texecute.beforeExecute = function(callback){\r\n\t\t\texecutable.callbacks.beforeExecute = callback;\r\n\t\t\treturn execute;\r\n\t\t};\r\n\t\texecute.canExecute = function(callback){\r\n\t\t\texecutable.callbacks.canExecute = callback;\r\n\t\t\treturn execute;\r\n\t\t};\r\n\t\texecute.result = function(){\r\n\t\t\tif(arguments.length == 1){\r\n\t\t\t\texecutable.callbacks.result = arguments[0];\r\n\t\t\t\treturn execute;\r\n\t\t\t}\r\n\t\t\treturn executable.result.result;\r\n\t\t};\r\n\t\texecute.complete = function(callback){\r\n\t\t\texecutable.callbacks.complete = callback;\r\n\t\t\treturn execute;\r\n\t\t};\r\n\t\texecute.clearValidationMessages = executable.clearValidationMessages.bind(executable);\r\n\t\t\r\n\t\treturn execute;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\tcreateCommand: function(name, parameters, callbacks){\r\n\t\t\treturn createExecutable(name, Executable.Command, parameters, callbacks);\r\n\t\t},\r\n\t\tcreateQuery: function(name, parameters, callbacks){\r\n\t\t\treturn createExecutable(name, Executable.Query, parameters, callbacks);\r\n\t\t},\r\n\t\tconfig: function(config){\r\n\t\t\tutils.extend(qvc.config, config);\r\n\t\t}\r\n\t}\r\n});",
    "\ndefine('ordnung/spa/Outlet',[\r\n\t\"knockout\"\r\n], function(\r\n\tko\r\n){\r\n\r\n\tfunction Outlet(element, document){\r\n\t\tthis.element = element;\r\n\t\tthis.document = document || window.document;\r\n\t}\r\n\r\n\tOutlet.prototype.unloadCurrentPage = function(){\r\n\t\tko.cleanNode(this.element);\r\n\t\tthis.element.innerHTML = \"\";\r\n\t};\r\n\r\n\tOutlet.prototype.setPageContent = function(content){\r\n\t\tthis.element.innerHTML = content;\r\n\t};\r\n\r\n\tOutlet.prototype.getPageTitle = function(){\r\n\t\tvar titleMetaTag = this.element.querySelector(\"meta[name=title]\");\r\n\t\treturn (titleMetaTag && titleMetaTag.getAttribute(\"content\"));\r\n\t};\r\n\r\n\tOutlet.prototype.setDocumentTitle = function(title){\r\n\t\tthis.document.title = title;\r\n\t};\r\n\r\n\tOutlet.prototype.extractAndRunPageJavaScript = function(){\r\n\t\tvar scripts = this.element.querySelectorAll(\"script\");\r\n\t\tfor(var i=0; i<scripts.length; i++){\r\n\t\t\tscripts[i].parentNode.removeChild(scripts[i]);\r\n\t\t\tif(scripts[i].id === '') throw new Error(\"The script must have an id\");\r\n\t\t\tif(this.document.getElementById(scripts[i].id) == null){\r\n\t\t\t\tvar script = this.document.createElement(\"script\");\r\n\t\t\t\tscript.id = scripts[i].id;\r\n\t\t\t\tscript.text = scripts[i].textContent;\r\n\t\t\t\tthis.document.body.appendChild(script);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tOutlet.prototype.indicatePageIsLoading = function(){\r\n\t\tthis.element.setAttribute(\"data-loading\", \"true\");\r\n\t};\r\n\r\n\tOutlet.prototype.pageHasLoaded = function(){\r\n\t\tthis.element.setAttribute(\"data-loading\", \"false\");\r\n\t};\r\n\r\n\treturn Outlet;\r\n\r\n});",
    "\ndefine('ordnung/spa/EventSubscriber',[\r\n\t\r\n], function(\r\n\t\r\n){\r\n\t\r\n\r\n\tfunction EventSubscriber(){\r\n\t\tvar _currentPageEventSubscribers = [];\r\n\r\n\t\tthis.unsubscribeAllEvents = function(){\r\n\t\t\tvar stopSubscription;\r\n\t\t\twhile(stopSubscription = _currentPageEventSubscribers.pop()){\r\n\t\t\t\tstopSubscription();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.subscribe = function(event, reaction){\r\n\t\t\t_currentPageEventSubscribers.push(function(){\r\n\t\t\t\tevent.dont(reaction);\r\n\t\t\t});\r\n\t\t\tevent(reaction);\r\n\t\t}\r\n\r\n\t\tthis.subscribeForever = function(event, reaction){\r\n\t\t\tevent(reaction);\r\n\t\t}\r\n\t}\r\n\r\n\treturn EventSubscriber\r\n});",
    "\n/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * A lightweight CommonJS Promises/A and when() implementation\n * when is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 2.3.0\n */\n(function(define, global) { 'use strict';\ndefine('when/when',[],function () {\n\n\t// Public API\n\n\twhen.promise   = promise;    // Create a pending promise\n\twhen.resolve   = resolve;    // Create a resolved promise\n\twhen.reject    = reject;     // Create a rejected promise\n\twhen.defer     = defer;      // Create a {promise, resolver} pair\n\n\twhen.join      = join;       // Join 2 or more promises\n\n\twhen.all       = all;        // Resolve a list of promises\n\twhen.map       = map;        // Array.map() for promises\n\twhen.reduce    = reduce;     // Array.reduce() for promises\n\twhen.settle    = settle;     // Settle a list of promises\n\n\twhen.any       = any;        // One-winner race\n\twhen.some      = some;       // Multi-winner race\n\n\twhen.isPromise = isPromise;  // Determine if a thing is a promise\n\n\t/**\n\t * Register an observer for a promise or immediate value.\n\t *\n\t * @param {*} promiseOrValue\n\t * @param {function?} [onFulfilled] callback to be called when promiseOrValue is\n\t *   successfully fulfilled.  If promiseOrValue is an immediate value, callback\n\t *   will be invoked immediately.\n\t * @param {function?} [onRejected] callback to be called when promiseOrValue is\n\t *   rejected.\n\t * @param {function?} [onProgress] callback to be called when progress updates\n\t *   are issued for promiseOrValue.\n\t * @returns {Promise} a new {@link Promise} that will complete with the return\n\t *   value of callback or errback or the completion value of promiseOrValue if\n\t *   callback and/or errback is not supplied.\n\t */\n\tfunction when(promiseOrValue, onFulfilled, onRejected, onProgress) {\n\t\t// Get a trusted promise for the input promiseOrValue, and then\n\t\t// register promise handlers\n\t\treturn resolve(promiseOrValue).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Trusted Promise constructor.  A Promise created from this constructor is\n\t * a trusted when.js promise.  Any other duck-typed promise is considered\n\t * untrusted.\n\t * @constructor\n\t * @param {function} sendMessage function to deliver messages to the promise's handler\n\t * @param {function?} inspect function that reports the promise's state\n\t * @name Promise\n\t */\n\tfunction Promise(sendMessage, inspect) {\n\t\tthis._message = sendMessage;\n\t\tthis.inspect = inspect;\n\t}\n\n\tPromise.prototype = {\n\t\t/**\n\t\t * Register a rejection handler.  Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\totherwise: function(onRejected) {\n\t\t\treturn this.then(undef, onRejected);\n\t\t},\n\n\t\t/**\n\t\t * Ensures that onFulfilledOrRejected will be called regardless of whether\n\t\t * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT\n\t\t * receive the promises' value or reason.  Any returned value will be disregarded.\n\t\t * onFulfilledOrRejected may throw or return a rejected promise to signal\n\t\t * an additional error.\n\t\t * @param {function} onFulfilledOrRejected handler to be called regardless of\n\t\t *  fulfillment or rejection\n\t\t * @returns {Promise}\n\t\t */\n\t\tensure: function(onFulfilledOrRejected) {\n\t\t\treturn this.then(injectHandler, injectHandler)['yield'](this);\n\n\t\t\tfunction injectHandler() {\n\t\t\t\treturn resolve(onFulfilledOrRejected());\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(function() { return value; })\n\t\t * @param  {*} value\n\t\t * @return {Promise} a promise that:\n\t\t *  - is fulfilled if value is not a promise, or\n\t\t *  - if value is a promise, will fulfill with its value, or reject\n\t\t *    with its reason.\n\t\t */\n\t\t'yield': function(value) {\n\t\t\treturn this.then(function() {\n\t\t\t\treturn value;\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Runs a side effect when this promise fulfills, without changing the\n\t\t * fulfillment value.\n\t\t * @param {function} onFulfilledSideEffect\n\t\t * @returns {Promise}\n\t\t */\n\t\ttap: function(onFulfilledSideEffect) {\n\t\t\treturn this.then(onFulfilledSideEffect)['yield'](this);\n\t\t},\n\n\t\t/**\n\t\t * Assumes that this promise will fulfill with an array, and arranges\n\t\t * for the onFulfilled to be called with the array as its argument list\n\t\t * i.e. onFulfilled.apply(undefined, array).\n\t\t * @param {function} onFulfilled function to receive spread arguments\n\t\t * @return {Promise}\n\t\t */\n\t\tspread: function(onFulfilled) {\n\t\t\treturn this.then(function(array) {\n\t\t\t\t// array may contain promises, so resolve its contents.\n\t\t\t\treturn all(array, function(array) {\n\t\t\t\t\treturn onFulfilled.apply(undef, array);\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Shortcut for .then(onFulfilledOrRejected, onFulfilledOrRejected)\n\t\t * @deprecated\n\t\t */\n\t\talways: function(onFulfilledOrRejected, onProgress) {\n\t\t\treturn this.then(onFulfilledOrRejected, onFulfilledOrRejected, onProgress);\n\t\t}\n\t};\n\n\t/**\n\t * Returns a resolved promise. The returned promise will be\n\t *  - fulfilled with promiseOrValue if it is a value, or\n\t *  - if promiseOrValue is a promise\n\t *    - fulfilled with promiseOrValue's value after it is fulfilled\n\t *    - rejected with promiseOrValue's reason after it is rejected\n\t * @param  {*} value\n\t * @return {Promise}\n\t */\n\tfunction resolve(value) {\n\t\treturn promise(function(resolve) {\n\t\t\tresolve(value);\n\t\t});\n\t}\n\n\t/**\n\t * Returns a rejected promise for the supplied promiseOrValue.  The returned\n\t * promise will be rejected with:\n\t * - promiseOrValue, if it is a value, or\n\t * - if promiseOrValue is a promise\n\t *   - promiseOrValue's value after it is fulfilled\n\t *   - promiseOrValue's reason after it is rejected\n\t * @param {*} promiseOrValue the rejected value of the returned {@link Promise}\n\t * @return {Promise} rejected {@link Promise}\n\t */\n\tfunction reject(promiseOrValue) {\n\t\treturn when(promiseOrValue, rejected);\n\t}\n\n\t/**\n\t * Creates a {promise, resolver} pair, either or both of which\n\t * may be given out safely to consumers.\n\t * The resolver has resolve, reject, and progress.  The promise\n\t * has then plus extended promise API.\n\t *\n\t * @return {{\n\t * promise: Promise,\n\t * resolve: function:Promise,\n\t * reject: function:Promise,\n\t * notify: function:Promise\n\t * resolver: {\n\t *\tresolve: function:Promise,\n\t *\treject: function:Promise,\n\t *\tnotify: function:Promise\n\t * }}}\n\t */\n\tfunction defer() {\n\t\tvar deferred, pending, resolved;\n\n\t\t// Optimize object shape\n\t\tdeferred = {\n\t\t\tpromise: undef, resolve: undef, reject: undef, notify: undef,\n\t\t\tresolver: { resolve: undef, reject: undef, notify: undef }\n\t\t};\n\n\t\tdeferred.promise = pending = promise(makeDeferred);\n\n\t\treturn deferred;\n\n\t\tfunction makeDeferred(resolvePending, rejectPending, notifyPending) {\n\t\t\tdeferred.resolve = deferred.resolver.resolve = function(value) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(value);\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\tresolvePending(value);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.reject  = deferred.resolver.reject  = function(reason) {\n\t\t\t\tif(resolved) {\n\t\t\t\t\treturn resolve(rejected(reason));\n\t\t\t\t}\n\t\t\t\tresolved = true;\n\t\t\t\trejectPending(reason);\n\t\t\t\treturn pending;\n\t\t\t};\n\n\t\t\tdeferred.notify  = deferred.resolver.notify  = function(update) {\n\t\t\t\tnotifyPending(update);\n\t\t\t\treturn update;\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new promise whose fate is determined by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t */\n\tfunction promise(resolver) {\n\t\treturn _promise(resolver, monitorApi.PromiseStatus && monitorApi.PromiseStatus());\n\t}\n\n\t/**\n\t * Creates a new promise, linked to parent, whose fate is determined\n\t * by resolver.\n\t * @param {function} resolver function(resolve, reject, notify)\n\t * @param {Promise?} status promise from which the new promise is begotten\n\t * @returns {Promise} promise whose fate is determine by resolver\n\t * @private\n\t */\n\tfunction _promise(resolver, status) {\n\t\tvar self, value, consumers = [];\n\n\t\tself = new Promise(_message, inspect);\n\t\tself.then = then;\n\n\t\t// Call the provider resolver to seal the promise's fate\n\t\ttry {\n\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t} catch(e) {\n\t\t\tpromiseReject(e);\n\t\t}\n\n\t\t// Return the promise\n\t\treturn self;\n\n\t\tfunction _message(type, args, resolve, notify) {\n\t\t\tconsumers ? consumers.push(deliver) : enqueue(function() { deliver(value); });\n\n\t\t\tfunction deliver(p) {\n\t\t\t\tp._message(type, args, resolve, notify);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns a snapshot of the promise's state at the instant inspect()\n\t\t * is called. The returned object is not live and will not update as\n\t\t * the promise's state changes.\n\t\t * @returns {{ state:String, value?:*, reason?:* }} status snapshot\n\t\t *  of the promise.\n\t\t */\n\t\tfunction inspect() {\n\t\t\treturn value ? value.inspect() : toPendingState();\n\t\t}\n\n\t\t/**\n\t\t * Register handlers for this promise.\n\t\t * @param [onFulfilled] {Function} fulfillment handler\n\t\t * @param [onRejected] {Function} rejection handler\n\t\t * @param [onProgress] {Function} progress handler\n\t\t * @return {Promise} new Promise\n\t\t */\n\t\tfunction then(onFulfilled, onRejected, onProgress) {\n\t\t\t/*jshint unused:false*/\n\t\t\tvar args = arguments;\n\t\t\treturn _promise(function(resolve, reject, notify) {\n\t\t\t\t_message('when', args, resolve, notify);\n\t\t\t}, status && status.observed());\n\t\t}\n\n\t\t/**\n\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t * @param {*|Promise} val resolution value\n\t\t */\n\t\tfunction promiseResolve(val) {\n\t\t\tif(!consumers) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue = coerce(val);\n\t\t\tscheduleConsumers(consumers, value);\n\t\t\tconsumers = undef;\n\n\t\t\tif(status) {\n\t\t\t\tupdateStatus(value, status);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Reject this promise with the supplied reason, which will be used verbatim.\n\t\t * @param {*} reason reason for the rejection\n\t\t */\n\t\tfunction promiseReject(reason) {\n\t\t\tpromiseResolve(rejected(reason));\n\t\t}\n\n\t\t/**\n\t\t * Issue a progress event, notifying all progress listeners\n\t\t * @param {*} update progress event payload to pass to all listeners\n\t\t */\n\t\tfunction promiseNotify(update) {\n\t\t\tif(consumers) {\n\t\t\t\tscheduleConsumers(consumers, progressed(update));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a fulfilled, local promise as a proxy for a value\n\t * NOTE: must never be exposed\n\t * @param {*} value fulfillment value\n\t * @returns {Promise}\n\t */\n\tfunction fulfilled(value) {\n\t\treturn near(\n\t\t\tnew NearFulfilledProxy(value),\n\t\t\tfunction() { return toFulfilledState(value); }\n\t\t);\n\t}\n\n\t/**\n\t * Creates a rejected, local promise with the supplied reason\n\t * NOTE: must never be exposed\n\t * @param {*} reason rejection reason\n\t * @returns {Promise}\n\t */\n\tfunction rejected(reason) {\n\t\treturn near(\n\t\t\tnew NearRejectedProxy(reason),\n\t\t\tfunction() { return toRejectedState(reason); }\n\t\t);\n\t}\n\n\t/**\n\t * Creates a near promise using the provided proxy\n\t * NOTE: must never be exposed\n\t * @param {object} proxy proxy for the promise's ultimate value or reason\n\t * @param {function} inspect function that returns a snapshot of the\n\t *  returned near promise's state\n\t * @returns {Promise}\n\t */\n\tfunction near(proxy, inspect) {\n\t\treturn new Promise(function(type, args, resolve) {\n\t\t\ttry {\n\t\t\t\tresolve(proxy[type].apply(proxy, args));\n\t\t\t} catch(e) {\n\t\t\t\tresolve(rejected(e));\n\t\t\t}\n\t\t}, inspect);\n\t}\n\n\t/**\n\t * Create a progress promise with the supplied update.\n\t * @private\n\t * @param {*} update\n\t * @return {Promise} progress promise\n\t */\n\tfunction progressed(update) {\n\t\treturn new Promise(function (type, args, _, notify) {\n\t\t\tvar onProgress = args[2];\n\t\t\ttry {\n\t\t\t\tnotify(typeof onProgress === 'function' ? onProgress(update) : update);\n\t\t\t} catch(e) {\n\t\t\t\tnotify(e);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Coerces x to a trusted Promise\n\t *\n\t * @private\n\t * @param {*} x thing to coerce\n\t * @returns {*} Guaranteed to return a trusted Promise.  If x\n\t *   is trusted, returns x, otherwise, returns a new, trusted, already-resolved\n\t *   Promise whose resolution value is:\n\t *   * the resolution value of x if it's a foreign promise, or\n\t *   * x if it's a value\n\t */\n\tfunction coerce(x) {\n\t\tif(x instanceof Promise) {\n\t\t\treturn x;\n\t\t}\n\n\t\tif (!(x === Object(x) && 'then' in x)) {\n\t\t\treturn fulfilled(x);\n\t\t}\n\n\t\treturn promise(function(resolve, reject, notify) {\n\t\t\tenqueue(function() {\n\t\t\t\ttry {\n\t\t\t\t\t// We must check and assimilate in the same tick, but not the\n\t\t\t\t\t// current tick, careful only to access promiseOrValue.then once.\n\t\t\t\t\tvar untrustedThen = x.then;\n\n\t\t\t\t\tif(typeof untrustedThen === 'function') {\n\t\t\t\t\t\tfcall(untrustedThen, x, resolve, reject, notify);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// It's a value, create a fulfilled wrapper\n\t\t\t\t\t\tresolve(fulfilled(x));\n\t\t\t\t\t}\n\n\t\t\t\t} catch(e) {\n\t\t\t\t\t// Something went wrong, reject\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Proxy for a near, fulfilled value\n\t * @param {*} value\n\t * @constructor\n\t */\n\tfunction NearFulfilledProxy(value) {\n\t\tthis.value = value;\n\t}\n\n\tNearFulfilledProxy.prototype.when = function(onResult) {\n\t\treturn typeof onResult === 'function' ? onResult(this.value) : this.value;\n\t};\n\n\t/**\n\t * Proxy for a near rejection\n\t * @param {*} value\n\t * @constructor\n\t */\n\tfunction NearRejectedProxy(reason) {\n\t\tthis.reason = reason;\n\t}\n\n\tNearRejectedProxy.prototype.when = function(_, onError) {\n\t\tif(typeof onError === 'function') {\n\t\t\treturn onError(this.reason);\n\t\t} else {\n\t\t\tthrow this.reason;\n\t\t}\n\t};\n\n\t/**\n\t * Schedule a task that will process a list of handlers\n\t * in the next queue drain run.\n\t * @private\n\t * @param {Array} handlers queue of handlers to execute\n\t * @param {*} value passed as the only arg to each handler\n\t */\n\tfunction scheduleConsumers(handlers, value) {\n\t\tenqueue(function() {\n\t\t\tvar handler, i = 0;\n\t\t\twhile (handler = handlers[i++]) {\n\t\t\t\thandler(value);\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction updateStatus(value, status) {\n\t\tvalue._message('when', [\n\t\t\tfunction ()  { status.fulfilled(); },\n\t\t\tfunction (r) { status.rejected(r); }\n\t\t], identity, identity);\n\t}\n\n\t/**\n\t * Determines if promiseOrValue is a promise or not\n\t *\n\t * @param {*} promiseOrValue anything\n\t * @returns {boolean} true if promiseOrValue is a {@link Promise}\n\t */\n\tfunction isPromise(promiseOrValue) {\n\t\treturn promiseOrValue && typeof promiseOrValue.then === 'function';\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * howMany of the supplied promisesOrValues have resolved, or will reject when\n\t * it becomes impossible for howMany to resolve, for example, when\n\t * (promisesOrValues.length - howMany) + 1 input promises reject.\n\t *\n\t * @param {Array} promisesOrValues array of anything, may contain a mix\n\t *      of promises and values\n\t * @param howMany {number} number of promisesOrValues to resolve\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to an array of howMany values that\n\t *  resolved first, or will reject with an array of\n\t *  (promisesOrValues.length - howMany) + 1 rejection reasons.\n\t */\n\tfunction some(promisesOrValues, howMany, onFulfilled, onRejected, onProgress) {\n\n\t\treturn when(promisesOrValues, function(promisesOrValues) {\n\n\t\t\treturn promise(resolveSome).then(onFulfilled, onRejected, onProgress);\n\n\t\t\tfunction resolveSome(resolve, reject, notify) {\n\t\t\t\tvar toResolve, toReject, values, reasons, fulfillOne, rejectOne, len, i;\n\n\t\t\t\tlen = promisesOrValues.length >>> 0;\n\n\t\t\t\ttoResolve = Math.max(0, Math.min(howMany, len));\n\t\t\t\tvalues = [];\n\n\t\t\t\ttoReject = (len - toResolve) + 1;\n\t\t\t\treasons = [];\n\n\t\t\t\t// No items in the input, resolve immediately\n\t\t\t\tif (!toResolve) {\n\t\t\t\t\tresolve(values);\n\n\t\t\t\t} else {\n\t\t\t\t\trejectOne = function(reason) {\n\t\t\t\t\t\treasons.push(reason);\n\t\t\t\t\t\tif(!--toReject) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\treject(reasons);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfulfillOne = function(val) {\n\t\t\t\t\t\t// This orders the values based on promise resolution order\n\t\t\t\t\t\tvalues.push(val);\n\t\t\t\t\t\tif (!--toResolve) {\n\t\t\t\t\t\t\tfulfillOne = rejectOne = identity;\n\t\t\t\t\t\t\tresolve(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(i = 0; i < len; ++i) {\n\t\t\t\t\t\tif(i in promisesOrValues) {\n\t\t\t\t\t\t\twhen(promisesOrValues[i], fulfiller, rejecter, notify);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction rejecter(reason) {\n\t\t\t\t\trejectOne(reason);\n\t\t\t\t}\n\n\t\t\t\tfunction fulfiller(val) {\n\t\t\t\t\tfulfillOne(val);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Initiates a competitive race, returning a promise that will resolve when\n\t * any one of the supplied promisesOrValues has resolved or will reject when\n\t * *all* promisesOrValues have rejected.\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise} promise that will resolve to the value that resolved first, or\n\t * will reject with an array of all rejected inputs.\n\t */\n\tfunction any(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\n\t\tfunction unwrapSingleResult(val) {\n\t\t\treturn onFulfilled ? onFulfilled(val[0]) : val[0];\n\t\t}\n\n\t\treturn some(promisesOrValues, 1, unwrapSingleResult, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Return a promise that will resolve only once all the supplied promisesOrValues\n\t * have resolved. The resolution value of the returned promise will be an array\n\t * containing the resolution values of each of the promisesOrValues.\n\t * @memberOf when\n\t *\n\t * @param {Array|Promise} promisesOrValues array of anything, may contain a mix\n\t *      of {@link Promise}s and values\n\t * @param {function?} [onFulfilled] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onRejected] DEPRECATED, use returnedPromise.then()\n\t * @param {function?} [onProgress] DEPRECATED, use returnedPromise.then()\n\t * @returns {Promise}\n\t */\n\tfunction all(promisesOrValues, onFulfilled, onRejected, onProgress) {\n\t\treturn _map(promisesOrValues, identity).then(onFulfilled, onRejected, onProgress);\n\t}\n\n\t/**\n\t * Joins multiple promises into a single returned promise.\n\t * @return {Promise} a promise that will fulfill when *all* the input promises\n\t * have fulfilled, or will reject when *any one* of the input promises rejects.\n\t */\n\tfunction join(/* ...promises */) {\n\t\treturn _map(arguments, identity);\n\t}\n\n\t/**\n\t * Settles all input promises such that they are guaranteed not to\n\t * be pending once the returned promise fulfills. The returned promise\n\t * will always fulfill, except in the case where `array` is a promise\n\t * that rejects.\n\t * @param {Array|Promise} array or promise for array of promises to settle\n\t * @returns {Promise} promise that always fulfills with an array of\n\t *  outcome snapshots for each input promise.\n\t */\n\tfunction settle(array) {\n\t\treturn _map(array, toFulfilledState, toRejectedState);\n\t}\n\n\t/**\n\t * Promise-aware array map function, similar to `Array.prototype.map()`,\n\t * but input array may contain promises or values.\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction map(array, mapFunc) {\n\t\treturn _map(array, mapFunc);\n\t}\n\n\t/**\n\t * Internal map that allows a fallback to handle rejections\n\t * @param {Array|Promise} array array of anything, may contain promises and values\n\t * @param {function} mapFunc map function which may return a promise or value\n\t * @param {function?} fallback function to handle rejected promises\n\t * @returns {Promise} promise that will fulfill with an array of mapped values\n\t *  or reject if any input promise rejects.\n\t */\n\tfunction _map(array, mapFunc, fallback) {\n\t\treturn when(array, function(array) {\n\n\t\t\treturn promise(resolveMap);\n\n\t\t\tfunction resolveMap(resolve, reject, notify) {\n\t\t\t\tvar results, len, toResolve, i;\n\n\t\t\t\t// Since we know the resulting length, we can preallocate the results\n\t\t\t\t// array to avoid array expansions.\n\t\t\t\ttoResolve = len = array.length >>> 0;\n\t\t\t\tresults = [];\n\n\t\t\t\tif(!toResolve) {\n\t\t\t\t\tresolve(results);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Since mapFunc may be async, get all invocations of it into flight\n\t\t\t\tfor(i = 0; i < len; i++) {\n\t\t\t\t\tif(i in array) {\n\t\t\t\t\t\tresolveOne(array[i], i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--toResolve;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction resolveOne(item, i) {\n\t\t\t\t\twhen(item, mapFunc, fallback).then(function(mapped) {\n\t\t\t\t\t\tresults[i] = mapped;\n\t\t\t\t\t\tnotify(mapped);\n\n\t\t\t\t\t\tif(!--toResolve) {\n\t\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, reject);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Traditional reduce function, similar to `Array.prototype.reduce()`, but\n\t * input may contain promises and/or values, and reduceFunc\n\t * may return either a value or a promise, *and* initialValue may\n\t * be a promise for the starting value.\n\t *\n\t * @param {Array|Promise} promise array or promise for an array of anything,\n\t *      may contain a mix of promises and values.\n\t * @param {function} reduceFunc reduce function reduce(currentValue, nextValue, index, total),\n\t *      where total is the total number of items being reduced, and will be the same\n\t *      in each call to reduceFunc.\n\t * @returns {Promise} that will resolve to the final reduced value\n\t */\n\tfunction reduce(promise, reduceFunc /*, initialValue */) {\n\t\tvar args = fcall(slice, arguments, 1);\n\n\t\treturn when(promise, function(array) {\n\t\t\tvar total;\n\n\t\t\ttotal = array.length;\n\n\t\t\t// Wrap the supplied reduceFunc with one that handles promises and then\n\t\t\t// delegates to the supplied.\n\t\t\targs[0] = function (current, val, i) {\n\t\t\t\treturn when(current, function (c) {\n\t\t\t\t\treturn when(val, function (value) {\n\t\t\t\t\t\treturn reduceFunc(c, value, i, total);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\treturn reduceArray.apply(array, args);\n\t\t});\n\t}\n\n\t// Snapshot states\n\n\t/**\n\t * Creates a fulfilled state snapshot\n\t * @private\n\t * @param {*} x any value\n\t * @returns {{state:'fulfilled',value:*}}\n\t */\n\tfunction toFulfilledState(x) {\n\t\treturn { state: 'fulfilled', value: x };\n\t}\n\n\t/**\n\t * Creates a rejected state snapshot\n\t * @private\n\t * @param {*} x any reason\n\t * @returns {{state:'rejected',reason:*}}\n\t */\n\tfunction toRejectedState(x) {\n\t\treturn { state: 'rejected', reason: x };\n\t}\n\n\t/**\n\t * Creates a pending state snapshot\n\t * @private\n\t * @returns {{state:'pending'}}\n\t */\n\tfunction toPendingState() {\n\t\treturn { state: 'pending' };\n\t}\n\n\t//\n\t// Internals, utilities, etc.\n\t//\n\n\tvar reduceArray, slice, fcall, nextTick, handlerQueue,\n\t\tsetTimeout, funcProto, call, arrayProto, monitorApi, undef;\n\n\t//\n\t// Shared handler queue processing\n\t//\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for\n\t// next-tick conflation.\n\n\thandlerQueue = [];\n\n\t/**\n\t * Enqueue a task. If the queue is not currently scheduled to be\n\t * drained, schedule it.\n\t * @param {function} task\n\t */\n\tfunction enqueue(task) {\n\t\tif(handlerQueue.push(task) === 1) {\n\t\t\tnextTick(drainQueue);\n\t\t}\n\t}\n\n\t/**\n\t * Drain the handler queue entirely, being careful to allow the\n\t * queue to be extended while it is being processed, and to continue\n\t * processing until it is truly empty.\n\t */\n\tfunction drainQueue() {\n\t\tvar task, i = 0;\n\n\t\twhile(task = handlerQueue[i++]) {\n\t\t\ttask();\n\t\t}\n\n\t\thandlerQueue = [];\n\t}\n\n\t// capture setTimeout to avoid being caught by fake timers\n\t// used in time based tests\n\tsetTimeout = global.setTimeout;\n\n\t// Allow attaching the monitor to when() if env has no console\n\tmonitorApi = typeof console != 'undefined' ? console : when;\n\n\t// Prefer setImmediate or MessageChannel, cascade to node,\n\t// vertx and finally setTimeout\n\t/*global setImmediate,MessageChannel,process,vertx*/\n\tif (typeof setImmediate === 'function') {\n\t\tnextTick = setImmediate.bind(global);\n\t} else if(typeof MessageChannel !== 'undefined') {\n\t\tvar channel = new MessageChannel();\n\t\tchannel.port1.onmessage = drainQueue;\n\t\tnextTick = function() { channel.port2.postMessage(0); };\n\t} else if (typeof process === 'object' && process.nextTick) {\n\t\tnextTick = process.nextTick;\n\t} else if (typeof vertx === 'object') {\n\t\tnextTick = vertx.runOnLoop;\n\t} else {\n\t\tnextTick = function(t) { setTimeout(t, 0); };\n\t}\n\n\t//\n\t// Capture/polyfill function and array utils\n\t//\n\n\t// Safe function calls\n\tfuncProto = Function.prototype;\n\tcall = funcProto.call;\n\tfcall = funcProto.bind\n\t\t? call.bind(call)\n\t\t: function(f, context) {\n\t\t\treturn f.apply(context, slice.call(arguments, 2));\n\t\t};\n\n\t// Safe array ops\n\tarrayProto = [];\n\tslice = arrayProto.slice;\n\n\t// ES5 reduce implementation if native not available\n\t// See: http://es5.github.com/#x15.4.4.21 as there are many\n\t// specifics and edge cases.  ES5 dictates that reduce.length === 1\n\t// This implementation deviates from ES5 spec in the following ways:\n\t// 1. It does not check if reduceFunc is a Callable\n\treduceArray = arrayProto.reduce ||\n\t\tfunction(reduceFunc /*, initialValue */) {\n\t\t\t/*jshint maxcomplexity: 7*/\n\t\t\tvar arr, args, reduced, len, i;\n\n\t\t\ti = 0;\n\t\t\tarr = Object(this);\n\t\t\tlen = arr.length >>> 0;\n\t\t\targs = arguments;\n\n\t\t\t// If no initialValue, use first item of array (we know length !== 0 here)\n\t\t\t// and adjust i to start at second item\n\t\t\tif(args.length <= 1) {\n\t\t\t\t// Skip to the first real element in the array\n\t\t\t\tfor(;;) {\n\t\t\t\t\tif(i in arr) {\n\t\t\t\t\t\treduced = arr[i++];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the end of the array without finding any real\n\t\t\t\t\t// elements, it's a TypeError\n\t\t\t\t\tif(++i >= len) {\n\t\t\t\t\t\tthrow new TypeError();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If initialValue provided, use it\n\t\t\t\treduced = args[1];\n\t\t\t}\n\n\t\t\t// Do the actual reduce\n\t\t\tfor(;i < len; ++i) {\n\t\t\t\tif(i in arr) {\n\t\t\t\t\treduced = reduceFunc(reduced, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reduced;\n\t\t};\n\n\tfunction identity(x) {\n\t\treturn x;\n\t}\n\n\treturn when;\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(); }, this);\n\ndefine('when', ['when/when'], function (main) { return main; });\n",
    "\n/** @license MIT License (c) copyright 2013 original author or authors */\n\n/**\n * callbacks.js\n *\n * Collection of helper functions for interacting with 'traditional',\n * callback-taking functions using a promise interface.\n *\n * @author Renato Zannon <renato.riccieri@gmail.com>\n * @contributor Brian Cavalier\n */\n\n(function(define) {\ndefine('when/callbacks',['require','./when'],function(require) {\n\n\tvar when, promise, slice;\n\n\twhen = require('./when');\n\tpromise = when.promise;\n\tslice = [].slice;\n\n\treturn {\n\t\tapply: apply,\n\t\tcall: call,\n\t\tlift: lift,\n\t\tbind: lift, // DEPRECATED alias for lift\n\t\tpromisify: promisify\n\t};\n\n\t/**\n\t * Takes a `traditional` callback-taking function and returns a promise for its\n\t * result, accepting an optional array of arguments (that might be values or\n\t * promises). It assumes that the function takes its callback and errback as\n\t * the last two arguments. The resolution of the promise depends on whether the\n\t * function will call its callback or its errback.\n\t *\n\t * @example\n\t *    var domIsLoaded = callbacks.apply($);\n\t *    domIsLoaded.then(function() {\n\t *\t\tdoMyDomStuff();\n\t *\t});\n\t *\n\t * @example\n\t *    function existingAjaxyFunction(url, callback, errback) {\n\t *\t\t// Complex logic you'd rather not change\n\t *\t}\n\t *\n\t *    var promise = callbacks.apply(existingAjaxyFunction, [\"/movies.json\"]);\n\t *\n\t *    promise.then(function(movies) {\n\t *\t\t// Work with movies\n\t *\t}, function(reason) {\n\t *\t\t// Handle error\n\t *\t});\n\t *\n\t * @param {function} asyncFunction function to be called\n\t * @param {Array} [extraAsyncArgs] array of arguments to asyncFunction\n\t * @returns {Promise} promise for the callback value of asyncFunction\n\t */\n\tfunction apply(asyncFunction, extraAsyncArgs) {\n\t\treturn _apply(asyncFunction, this, extraAsyncArgs);\n\t}\n\n\t/**\n\t * Apply helper that allows specifying thisArg\n\t * @private\n\t */\n\tfunction _apply(asyncFunction, thisArg, extraAsyncArgs) {\n\t\treturn when.all(extraAsyncArgs || []).then(function(args) {\n\t\t\treturn promise(function(resolve, reject) {\n\t\t\t\tvar asyncArgs = args.concat(\n\t\t\t\t\talwaysUnary(resolve),\n\t\t\t\t\talwaysUnary(reject)\n\t\t\t\t);\n\n\t\t\t\tasyncFunction.apply(thisArg, asyncArgs);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Works as `callbacks.apply` does, with the difference that the arguments to\n\t * the function are passed individually, instead of as an array.\n\t *\n\t * @example\n\t *    function sumInFiveSeconds(a, b, callback) {\n\t *\t\tsetTimeout(function() {\n\t *\t\t\tcallback(a + b);\n\t *\t\t}, 5000);\n\t *\t}\n\t *\n\t *    var sumPromise = callbacks.call(sumInFiveSeconds, 5, 10);\n\t *\n\t *    // Logs '15' 5 seconds later\n\t *    sumPromise.then(console.log);\n\t *\n\t * @param {function} asyncFunction function to be called\n\t * @param {...*} args arguments that will be forwarded to the function\n\t * @returns {Promise} promise for the callback value of asyncFunction\n\t */\n\tfunction call(asyncFunction/*, arg1, arg2...*/) {\n\t\treturn _apply(asyncFunction, this, slice.call(arguments, 1));\n\t}\n\n\t/**\n\t * Takes a 'traditional' callback/errback-taking function and returns a function\n\t * that returns a promise instead. The resolution/rejection of the promise\n\t * depends on whether the original function will call its callback or its\n\t * errback.\n\t *\n\t * If additional arguments are passed to the `bind` call, they will be prepended\n\t * on the calls to the original function, much like `Function.prototype.bind`.\n\t *\n\t * The resulting function is also \"promise-aware\", in the sense that, if given\n\t * promises as arguments, it will wait for their resolution before executing.\n\t *\n\t * @example\n\t *    function traditionalAjax(method, url, callback, errback) {\n\t *\t\tvar xhr = new XMLHttpRequest();\n\t *\t\txhr.open(method, url);\n\t *\n\t *\t\txhr.onload = callback;\n\t *\t\txhr.onerror = errback;\n\t *\n\t *\t\txhr.send();\n\t *\t}\n\t *\n\t *    var promiseAjax = callbacks.bind(traditionalAjax);\n\t *    promiseAjax(\"GET\", \"/movies.json\").then(console.log, console.error);\n\t *\n\t *    var promiseAjaxGet = callbacks.bind(traditionalAjax, \"GET\");\n\t *    promiseAjaxGet(\"/movies.json\").then(console.log, console.error);\n\t *\n\t * @param {Function} f traditional async function to be decorated\n\t * @param {...*} [args] arguments to be prepended for the new function\n\t * @returns {Function} a promise-returning function\n\t */\n\tfunction lift(f/*, args...*/) {\n\t\tvar args = slice.call(arguments, 1);\n\t\treturn function() {\n\t\t\treturn _apply(f, this, args.concat(slice.call(arguments)));\n\t\t};\n\t}\n\n\t/**\n\t * `promisify` is a version of `bind` that allows fine-grained control over the\n\t * arguments that passed to the underlying function. It is intended to handle\n\t * functions that don't follow the common callback and errback positions.\n\t *\n\t * The control is done by passing an object whose 'callback' and/or 'errback'\n\t * keys, whose values are the corresponding 0-based indexes of the arguments on\n\t * the function. Negative values are interpreted as being relative to the end\n\t * of the arguments array.\n\t *\n\t * If arguments are given on the call to the 'promisified' function, they are\n\t * intermingled with the callback and errback. If a promise is given among them,\n\t * the execution of the function will only occur after its resolution.\n\t *\n\t * @example\n\t *    var delay = callbacks.promisify(setTimeout, {\n\t *\t\tcallback: 0\n\t *\t});\n\t *\n\t *    delay(100).then(function() {\n\t *\t\tconsole.log(\"This happens 100ms afterwards\");\n\t *\t});\n\t *\n\t * @example\n\t *    function callbackAsLast(errback, followsStandards, callback) {\n\t *\t\tif(followsStandards) {\n\t *\t\t\tcallback(\"well done!\");\n\t *\t\t} else {\n\t *\t\t\terrback(\"some programmers just want to watch the world burn\");\n\t *\t\t}\n\t *\t}\n\t *\n\t *    var promisified = callbacks.promisify(callbackAsLast, {\n\t *\t\tcallback: -1,\n\t *\t\terrback:   0,\n\t *\t});\n\t *\n\t *    promisified(true).then(console.log, console.error);\n\t *    promisified(false).then(console.log, console.error);\n\t *\n\t * @param {Function} asyncFunction traditional function to be decorated\n\t * @param {object} positions\n\t * @param {number} [positions.callback] index at which asyncFunction expects to\n\t *  receive a success callback\n\t * @param {number} [positions.errback] index at which asyncFunction expects to\n\t *  receive an error callback\n\t *  @returns {function} promisified function that accepts\n\t */\n\tfunction promisify(asyncFunction, positions) {\n\n\t\treturn function() {\n\t\t\tvar thisArg = this;\n\t\t\treturn when.all(arguments).then(function(args) {\n\t\t\t\treturn promise(applyPromisified);\n\n\t\t\t\tfunction applyPromisified(resolve, reject) {\n\t\t\t\t\tvar callbackPos, errbackPos;\n\n\t\t\t\t\tif('callback' in positions) {\n\t\t\t\t\t\tcallbackPos = normalizePosition(args, positions.callback);\n\t\t\t\t\t}\n\n\t\t\t\t\tif('errback' in positions) {\n\t\t\t\t\t\terrbackPos = normalizePosition(args, positions.errback);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(errbackPos < callbackPos) {\n\t\t\t\t\t\tinsertCallback(args, errbackPos, reject);\n\t\t\t\t\t\tinsertCallback(args, callbackPos, resolve);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinsertCallback(args, callbackPos, resolve);\n\t\t\t\t\t\tinsertCallback(args, errbackPos, reject);\n\t\t\t\t\t}\n\n\t\t\t\t\tasyncFunction.apply(thisArg, args);\n\t\t\t\t}\n\n\t\t\t});\n\t\t};\n\t}\n\n\tfunction normalizePosition(args, pos) {\n\t\treturn pos < 0 ? (args.length + pos + 2) : pos;\n\t}\n\n\tfunction insertCallback(args, pos, callback) {\n\t\tif(pos != null) {\n\t\t\tcallback = alwaysUnary(callback);\n\t\t\tif(pos < 0) {\n\t\t\t\tpos = args.length + pos + 2;\n\t\t\t}\n\t\t\targs.splice(pos, 0, callback);\n\t\t}\n\n\t}\n\n\tfunction alwaysUnary(fn) {\n\t\treturn function() {\n\t\t\tif(arguments.length <= 1) {\n\t\t\t\tfn.apply(this, arguments);\n\t\t\t} else {\n\t\t\t\tfn.call(this, slice.call(arguments));\n\t\t\t}\n\t\t};\n\t}\n});\n})(\n\ttypeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); }\n\t// Boilerplate for AMD and Node\n);\n",
    "\ndefine('ordnung/spa/applyViewModels',[\"ordnung/utils\", \"knockout\", \"when\", \"when/callbacks\"], function (utils, ko, when, callbacks) {\r\n\r\n\r\n\tfunction getAttributes(target){\r\n\r\n\t\tvar viewModelName = target.getAttribute(\"data-viewmodel\");\r\n\t\tvar model = target.getAttribute(\"data-model\");\r\n\t\tif (model && model.indexOf(\"{\") == 0) {\r\n\t\t\tmodel = JSON.parse(model);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttarget: target,\r\n\t\t\tviewModelName: viewModelName,\r\n\t\t\tmodel: model\r\n\t\t};\r\n\t}\r\n\r\n\r\n\tfunction loadViewModel(data){\r\n\t\treturn callbacks.call(require, [\r\n\t\t\tdata.viewModelName\r\n\t\t]).then(function(ViewModel){\r\n\t\t\tdata.ViewModel = ViewModel;\r\n\t\t\treturn data;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction applyViewModel(subscribe, data) {\r\n\t\tvar viewModel = new data.ViewModel(data.model, subscribe);\r\n\t\tko.applyBindings(viewModel, data.target);\r\n\t};\r\n\r\n\treturn function (domElement, subscribe) {\r\n\r\n\t\tdomElement = domElement || document.body;\r\n\r\n\t\tvar elementList = utils.toArray(domElement.querySelectorAll(\"*[data-viewmodel]\"));\r\n\r\n\t\tvar viewModelsLoaded = elementList.map(getAttributes).map(loadViewModel);\r\n\r\n\t\treturn when.all(viewModelsLoaded).then(function(list){\r\n\t\t\tlist.forEach(applyViewModel.bind(null, subscribe))\r\n\t\t});\r\n\t};\r\n});",
    "\ndefine('ordnung/spa/hashNavigation',[\r\n\t\"ordnung/utils\"\r\n],function(\r\n\t_\r\n){\r\n\r\n\r\n\t\r\n\tfunction newPath(currentPath, link, index){\r\n\t\tvar isRelative = _.startsWith(link, '/') === false;\r\n\t\tvar isFolder = _.endsWith(link, '/');\r\n\t\t\r\n\t\tif(link === \"/\"){\r\n\t\t\tvar path = [];\r\n\t\t}else if(link === \"\"){\r\n\t\t\tvar path = [index];\r\n\t\t}else{\r\n\t\t\tvar path = _.trim(link, \"/\").split(\"/\");\r\n\t\t}\r\n\r\n\t\tif(isFolder){\r\n\t\t\tpath.push(index);\r\n\t\t}\r\n\t\tif(isRelative){\r\n\t\t\tpath = _.popTail(currentPath).concat(path);\r\n\t\t}\r\n\r\n\t\tvar out = [];\r\n\r\n\t\tfor(var i = path.length>>>0; i--;){\r\n\t\t\tif(path[i] === \"\"){\r\n\t\t\t\tcontinue;\r\n\t\t\t}else if(path[i] === \".\"){\r\n\t\t\t\tcontinue;\r\n\t\t\t}else if(path[i] === \"..\") {\r\n\t\t\t\ti--;\r\n\t\t\t}else{\r\n\t\t\t\tout.unshift(path[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction hashChanged(config, onPageChanged, document){\r\n\r\n\t\tvar path = _.trim(document.location.hash, '#');\r\n\r\n\t\tvar isRelative = _.startsWith(path, '/') == false;\r\n\t\tvar isFolder = _.endsWith(path, '/');\r\n\r\n\t\tif(isRelative || isFolder){\r\n\t\t\tvar newHash = newPath(this.currentPath, path, config.index).join('/');\r\n\t\t\tdocument.location.replace(\"#/\" + newHash);\r\n\t\t}else{\r\n\t\t\tthis.currentPath = newPath(this.currentPath, path, config.index);\r\n\t\t\tonPageChanged(this.currentPath.join('/'));\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\tfunction startHashNavigation(config, onPageChanged, doc, global){\r\n\t\tdoc = doc || document;\r\n\t\tglobal = global || window;\r\n\r\n\t\tvar state = {\r\n\t\t\tcurrentPath: []\r\n\t\t};\r\n\t\tvar onHashChanged = hashChanged.bind(state, config, onPageChanged, doc);\r\n\t\tonHashChanged();\r\n\t\t_.addEventListener(global, \"hashchange\", onHashChanged, false);\r\n\r\n\t\treturn {\r\n\t\t\tstop: function(){\r\n\t\t\t\tglobal.removeEventListener(\"hashchange\", onHashChanged, false);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\r\n\treturn {\r\n\t\tstart: startHashNavigation\r\n\t};\r\n\r\n});",
    "\ndefine('ordnung/spa/PageLoader',[\r\n\t\"ordnung/ajax\"\r\n], function(\r\n\tajax\r\n){\r\n\r\n\tfunction PageLoader(pathToUrl){\r\n\t\tthis.pathToUrl = pathToUrl;\r\n\t\tthis.currentXHR = null;\r\n\t}\r\n\r\n\tPageLoader.prototype.loadPage = function(path, resolver){\r\n\r\n\t\tthis.abort();\r\n\r\n\t\tthis.currentXHR = ajax(this.pathToUrl(path), {}, \"GET\", function(xhr){\r\n\t\t\tif(xhr.status === 200)\r\n\t\t\t\tresolver.resolve(xhr.responseText);\r\n\t\t\telse\r\n\t\t\t\tresolver.reject(xhr.responseText);\r\n\t\t});\r\n\t};\r\n\r\n\tPageLoader.prototype.abort = function(){\r\n\t\tif(this.currentXHR && this.currentXHR.readyState !== 4){\r\n\t\t\tthis.currentXHR.abort();\r\n\t\t}\r\n\t};\r\n\r\n\treturn PageLoader;\r\n});",
    "\ndefine('ordnung/spa/Templates',[\r\n\t\"ordnung/spa/PageLoader\",\r\n\t\"ordnung/utils\",\r\n\t\"when\"\r\n], function(\r\n\tPageLoader,\r\n\tutils,\r\n\twhen\r\n){\r\n\r\n\tfunction findTemplatesInDocument(doc){\r\n\r\n\t\tvar nodeList = doc.querySelectorAll(\"[type='text/page-template']\");\r\n\t\tvar nodes = utils.toArray(nodeList);\r\n\t\tvar templateList = nodes.map(function(template){\r\n\t\t\treturn {\r\n\t\t\t\tid: template.id.toLowerCase(),\r\n\t\t\t\tcontent: template.innerHTML\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\treturn utils.arrayToObject(templateList, function(item, object){\r\n\t\t\tobject[item.id] = item.content;\r\n\t\t});\r\n\t}\r\n\r\n\r\n\tfunction Templates(document, config){\r\n\t\tthis.pageLoader = new PageLoader(config && config.pathToUrl || function(a){ return a; });\r\n\r\n\t\tthis.templates = findTemplatesInDocument(document);\r\n\t}\r\n\r\n\tTemplates.prototype.getTemplate = function(path){\r\n\r\n\t\tvar deferred = when.defer();\r\n\r\n\t\tthis.pageLoader.abort();\r\n\r\n\t\tvar normalizedPath = path.toLowerCase();\r\n\r\n\t\tif(normalizedPath in this.templates){\r\n\t\t\tdeferred.resolve(this.templates[normalizedPath]);\r\n\t\t}else{\r\n\t\t\tthis.pageLoader.loadPage(path, deferred.resolver);\r\n\t\t}\r\n\r\n\r\n\t\treturn deferred.promise;\r\n\t};\r\n\r\n\treturn Templates;\r\n});",
    "\ndefine('ordnung/spa',[\r\n\t\"ordnung/spa/Outlet\",\r\n\t\"ordnung/spa/EventSubscriber\",\r\n\t\"ordnung/spa/applyViewModels\",\r\n\t\"ordnung/spa/hashNavigation\",\r\n\t\"ordnung/spa/Templates\",\r\n\t\"ordnung/utils\"\r\n], function(\r\n\tOutlet,\r\n\tEventSubscriber,\r\n\tapplyViewModels,\r\n\thashNavigation,\r\n\tTemplates,\r\n\tutils\r\n){\r\n\r\n\tvar _config = {\r\n\t\t\tindex: \"index\"\r\n\t\t},\r\n\t\t_document,\r\n\t\t_outlet,\r\n\t\t_originalTitle,\r\n\t\t_templates,\r\n\t\t_currentPageEventSubscriber;\r\n\r\n\tfunction applyContent(content){\r\n\t\t_outlet.unloadCurrentPage();\r\n\t\t_outlet.setPageContent(content);\r\n\t\t_outlet.setDocumentTitle(_outlet.getPageTitle() || _originalTitle);\r\n\t\t_outlet.extractAndRunPageJavaScript();\r\n\t\treturn applyViewModels(_outlet.element, _currentPageEventSubscriber.subscribe);\r\n\t}\r\n\r\n\tfunction pageChanged(path){\r\n\t\t_outlet.indicatePageIsLoading();\r\n\t\t_currentPageEventSubscriber.unsubscribeAllEvents();\r\n\t\treturn _templates.getTemplate(path)\r\n\t\t\t.then(applyContent)\r\n\t\t\t.then(function(){\r\n\t\t\t\t_outlet.pageHasLoaded();\r\n\t\t\t});\r\n\t}\r\n\r\n\tfunction start(config, document){\r\n\t\t_document = document || window.document;\r\n\t\t_config = utils.extend(_config, config);\r\n\t\t_outlet = new Outlet(_document.querySelector(\"[data-outlet]\"), _document);\r\n\t\t_originalTitle = document.title;\r\n\t\t_templates = new Templates(_document, _config);\r\n\t\t_currentPageEventSubscriber = new EventSubscriber();\r\n\r\n\t\treturn applyViewModels(_document, _currentPageEventSubscriber.subscribeForever).then(function(){\r\n\t\t\thashNavigation.start(_config, pageChanged, _document);\r\n\t\t});\r\n\t}\r\n\r\n\treturn {\r\n\t\tstart: start\r\n\t};\r\n});",
    "\ndefine('ordnung/proclaimWhen',[], function () {\r\n\r\n\tfunction publish(name, event, data) {\r\n\t\tevent.subscribers.forEach(function (item) {\r\n\t\t\titem.apply(item, data);\r\n\t\t});\r\n\t}\r\n\r\n\tfunction subscribeTo(name, event, subscriber) {\r\n\t\tevent.subscribers.push(subscriber);\r\n\t}\r\n\t\r\n\tfunction unsubscribeTo(name, event, subscriber){\r\n\t\tvar index = event.subscribers.indexOf(subscriber);\r\n\t\tevent.subscribers.splice(index, 1);\r\n\t}\r\n\tfunction extendEvent(name, event){\r\n\t\tevent.subscribers = [];\r\n\r\n\t\tvar extendedEvent = function(){\r\n\t\t\tif(arguments.length == 1 && typeof arguments[0] === \"function\"){\r\n\t\t\t\tsubscribeTo(name, event, arguments[0]);\r\n\t\t\t}else{\r\n\t\t\t\tpublish(name, event, arguments);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\textendedEvent.dont = function(subscriber){\r\n\t\t\tunsubscribeTo(name, event, subscriber);\r\n\t\t};\r\n\r\n\t\treturn extendedEvent;\r\n\t}\r\n\t\r\n\tfunction extend(events){\r\n\t\tfor(var i in events){\r\n\t\t\tevents[i] = extendEvent(i, events[i]);\r\n\t\t}\r\n\t\treturn events;\r\n\t}\r\n\r\n\tfunction create(arg1, arg2){\r\n\t\tif(arg2)\r\n\t\t\treturn extendEvent(arg1, arg2);\r\n\t\telse\r\n\t\t\treturn extendEvent(\"anonymous event\", arg1)\r\n\t}\r\n\r\n\treturn {\r\n\t\textend: extend,\r\n\t\tcreate: create\r\n\t};\r\n\t\r\n});\r\n",
    "\ndefine('ordnung/qvc/constraints/NotEmpty',[], function(){\r\n\tfunction NotEmpty(attributes){\r\n\t\t\r\n\t}\r\n\t\r\n\tNotEmpty.prototype.isValid = function(value){\r\n\t\tif(value == null) return false;\r\n\t\tif(typeof value == \"string\" && value.length == 0) return false;\r\n\t\treturn true;\r\n\t};\r\n\t\r\n\treturn NotEmpty;\r\n});",
    "\ndefine('ordnung/qvc/constraints/Pattern',[], function(){\r\n\tfunction Pattern(attributes){\t\t\r\n\r\n\t\tattributes.flags = attributes.flags || [];\r\n\t\t\r\n\t\tvar flags = '';\r\n\t\tif(attributes.flags.indexOf(\"CASE_INSENSITIVE\") >= 0) flags += 'i';\r\n\t\t\r\n\t\tthis.regex = new RegExp(attributes.regexp, flags);\r\n\t}\r\n\t\r\n\t\r\n\tPattern.prototype.isValid = function(value){\r\n\t\t\r\n\t\tif(value == null) return false;\r\n\t\t\r\n\t\tvar result = this.regex.exec(value);\r\n\t\t\r\n\t\tif(result == null) return false;\r\n\t\t\r\n\t\treturn result[0] == value;\r\n\t};\r\n\t\r\n\t\r\n\treturn Pattern;\r\n});"
  ]
}